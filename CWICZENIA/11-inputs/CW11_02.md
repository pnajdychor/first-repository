# Exercise: GitHub Actions Workflow with Inputs (Docker + GHCR)

## 1. Goal of the exercise (EN)

In this exercise you will create a GitHub Actions workflow file that:

- Builds a Docker image for an Nginx-based demo application.
- Uses multiple **typed inputs** (string, choice, number, boolean, environment) passed via `workflow_dispatch`.
- Optionally pushes the built image to **GitHub Container Registry (GHCR)**.
- Uses a **GitHub Environment** selected at dispatch time.

Your final result should be a workflow YAML file logically and structurally equivalent to the specification described below.

---

## 2. File and location (EN)

1. In your repository, create the following folder structure (if it does not exist):
   - `.github/workflows/`

2. Inside this folder, create a new file, for example:
   - `.github/workflows/11-inputs-build-nginx.yml`

3. All the following steps describe what you must put into this file, line by line / block by block.

---

## 3. Workflow header and trigger (EN)

### 3.1. Workflow name

Add a human-readable workflow name at the top of the file:

- The `name` field should be: `11-inputs - Build Nginx image`

Explanation:

- `name:` — top-level key that defines how the workflow will be displayed in the GitHub Actions UI.
- `11-inputs - Build Nginx image` — a descriptive name telling that this is exercise number 11 and that the workflow builds an Nginx image.

### 3.2. Trigger configuration (`on:` + `workflow_dispatch`)

Under the name, define the trigger block so that the workflow is started **manually** with parameters:

1. Add the `on:` key.
2. Under `on:`, define a `workflow_dispatch:` block.
3. Inside `workflow_dispatch:`, define an `inputs:` block that contains all the inputs listed below.

The structure should look like:

- `on:`
  - `workflow_dispatch:`
    - `inputs:`
      - `image_name: ...`
      - `app_env: ...`
      - `build_number: ...`
      - `push_image: ...`
      - `deploy_environment: ...`

Each input must be defined with its type, description and default / required options as described in the next section.

---

## 4. Defining inputs (EN)

Inside `on.workflow_dispatch.inputs`, define the following inputs.

### 4.1. `image_name` (string)

Add an input named `image_name`:

- `description`: `"Nazwa obrazu (bez tagu)"` (this is a description in Polish; keep it as-is).
- `type`: `string`
- `required`: `true`
- `default`: `"demo-nginx"`

Explanation:

- This input lets the user choose the Docker image name (without the tag).
- By default, the image name will be `demo-nginx` if the user does not change it.

### 4.2. `app_env` (choice)

Add an input named `app_env` that allows selecting application environment:

- `description`: `"Środowisko aplikacji (wpływa na tag)"`
- `type`: `choice`
- `options`:
  - `dev`
  - `staging`
  - `prod`
- `default`: `dev`

Explanation:

- `type: choice` — the user chooses from a fixed list.
- The selected value will be used as part of the image tag (for example `dev-1`, `prod-3`, etc.).

### 4.3. `build_number` (number)

Add an input named `build_number`:

- `description`: `"Numer builda (dodawany do tagu)"`
- `type`: `number`
- `required`: `true`
- `default`: `1`

Explanation:

- This input is numeric and represents the build number.
- It will be appended to the tag, for example `dev-1`, `dev-2`, etc.

### 4.4. `push_image` (boolean)

Add an input named `push_image`:

- `description`: `"Czy wypchnąć obraz do rejestru GHCR?"`
- `type`: `boolean`
- `default`: `false`

Explanation:

- This is a true/false switch.
- If set to `true`, the workflow will log in to GHCR and push the built image.
- If `false`, the image will only be built locally on the runner.

### 4.5. `deploy_environment` (environment)

Add an input named `deploy_environment`:

- `description`: `"GitHub Environment (np. dev-env, staging-env, prod-env)"`
- `type`: `environment`
- `required`: `true`

Explanation:

- This input lets the user choose a GitHub **Environment** (like `dev-env`, `staging-env`, `prod-env`) when triggering the workflow.
- Later, this input value will be used to set the job’s `environment:` field.

---

## 5. Defaults for job steps (EN)

Add a top-level `defaults:` block after the `on:` section, to define common settings for all `run` steps:

- `defaults:`
  - `run:`
    - `shell: bash`
    - `working-directory: ./CWICZENIA/11-inputs`

Explanation of each line:

- `defaults:` — top-level key to define default settings for steps.
- `run:` — a nested key for defaults related to script running settings.
- `shell: bash` — all `run:` commands will use Bash shell by default.
- `working-directory: ./CWICZENIA/11-inputs` — each script step (without explicit override) will execute in this directory.

This means you should have the Docker context (including the Dockerfile) in `./CWICZENIA/11-inputs` relative to repository root.

---

## 6. Job definition (EN)

### 6.1. Job name and runner

1. Create a `jobs:` top-level block.
2. Inside it, define a job named `build-and-optional-push`.
3. For this job:

   - `name: Build Docker image (11-inputs)`
   - `runs-on: ubuntu-latest`

Explanation:

- `jobs:` — root key for all jobs.
- `build-and-optional-push:` — internal job ID.
- `name:` — human-friendly job label in the UI.
- `runs-on: ubuntu-latest` — use the latest Ubuntu GitHub-hosted runner.

### 6.2. Job environment from input

Inside the job, set the `environment:` field using the `deploy_environment` input:

- `environment: ${{ inputs.deploy_environment }}`

Explanation:

- This assigns the GitHub Environment selected at dispatch to the whole job.
- The syntax `${{ ... }}` is GitHub Actions expression syntax.

### 6.3. Permissions

Configure permissions for the job:

- `permissions:`
  - `contents: read`
  - `packages: write`
  - `id-token: write`

Explanation:

- `contents: read` — allows reading repository contents.
- `packages: write` — required to push images to GHCR (which is a package registry).
- `id-token: write` — prepares for possible OIDC-based workflows (and is used often with environments).

---

## 7. Steps in the job (EN)

Define a `steps:` block inside the job and then add the following steps in order.

### 7.1. Step: Checkout repo

First, check out the repository code:

- `- name: Checkout repo`
- `uses: actions/checkout@v4`

Explanation:

- `-` — new item in the `steps` list.
- `name:` — label of the step.
- `uses:` — means this step uses a prebuilt GitHub Action (here: official checkout action).

### 7.2. Step: Display chosen parameters

Next, add a step that prints all selected inputs to the log:

- `- name: Pokaz wybrane parametry`
- `run: |`
  - echo a header line: `"Wybrane parametry uruchomienia:"`
  - echo each input using GitHub expression syntax, for example:
    - `image_name      = ${{ inputs.image_name }}`
    - `app_env         = ${{ inputs.app_env }}`
    - `build_number    = ${{ inputs.build_number }}`
    - `push_image      = ${{ inputs.push_image }}`
    - `deploy_environment (GitHub) = ${{ inputs.deploy_environment }}`

Explanation:

- The `run: |` block starts a multi-line Bash script.
- Each `echo` prints the value of one input so that the logs show what was chosen when the workflow was triggered.

### 7.3. Step: Build Docker image

Add a step that builds a Docker image using all of the inputs:

- `- name: Build Docker image (z użyciem wszystkich inputów)`
- `run: |` followed by a Bash script that:

  1. Assigns shell variables from inputs:
     - `IMAGE_NAME="${{ inputs.image_name }}"`
     - `APP_ENV="${{ inputs.app_env }}"`
     - `BUILD_NUMBER="${{ inputs.build_number }}"`

  2. Builds an image tag using environment and build number:
     - `IMAGE_TAG="${APP_ENV}-${BUILD_NUMBER}"`
       - For example: `dev-1`, `staging-5`, `prod-10`.

  3. Converts the repository owner to lowercase for GHCR:
     - `OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')`
       - GHCR requires the owner part to be lowercase.

  4. Composes the full image URI:
     - `IMAGE_URI="ghcr.io/${OWNER_LOWER}/${IMAGE_NAME}:${IMAGE_TAG}"`

  5. Prints information:
     - `echo "Buduję obraz: ${IMAGE_URI}"`
     - `echo "Kontekst builda: $(pwd)"`

  6. Runs `docker build` with build arguments:
     - `docker build \`
       - `--build-arg APP_ENV="${APP_ENV}" \`
       - `--build-arg BUILD_NUMBER="${BUILD_NUMBER}" \`
       - `-t "${IMAGE_URI}" .`

  7. Prints that the local image is ready:
     - `echo "Gotowy lokalny obraz: ${IMAGE_URI}"`

Explanation:

- The script uses the inputs to construct a deterministic image name and tag.
- Build arguments (`APP_ENV`, `BUILD_NUMBER`) are passed into the Docker build context for potential use inside the Dockerfile.
- The final Docker image is tagged with the GHCR URI.

### 7.4. Step: Login to GHCR (conditional)

Add a step that logs in to GHCR **only if** `push_image` is `true`:

- `- name: Login do GHCR`
- `if: ${{ inputs.push_image }}`
- `run: |`
  - `echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin`

Explanation:

- `if: ${{ inputs.push_image }}` — the step is executed only when the boolean input evaluates to true.
- `secrets.GITHUB_TOKEN` — automatically provided token used to authenticate to GHCR.
- `github.actor` — the user or app that triggered the workflow.

### 7.5. Step: Push Docker image (conditional)

Add the final step that pushes the image to GHCR, also guarded by the same condition:

- `- name: Push Docker image (tylko jeśli push_image == true)`
- `if: ${{ inputs.push_image }}`
- `run: |` with a script that:

  1. Reconstructs the same variables as in the build step:
     - `IMAGE_NAME="${{ inputs.image_name }}"`
     - `APP_ENV="${{ inputs.app_env }}"`
     - `BUILD_NUMBER="${{ inputs.build_number }}"`
     - `IMAGE_TAG="${APP_ENV}-${BUILD_NUMBER}"`
     - `OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')`
     - `IMAGE_URI="ghcr.io/${OWNER_LOWER}/${IMAGE_NAME}:${IMAGE_TAG}"`

  2. Prints which image is being pushed:
     - `echo "Wypycham obraz: ${IMAGE_URI}"`

  3. Executes the push:
     - `docker push "${IMAGE_URI}"`

Explanation:

- This step uses the same naming logic to ensure that exactly the built image is pushed.
- It is skipped if `push_image` is `false`.

---

## 8. What you should have at the end (EN)

By the end of the exercise, your `.github/workflows/...yml` file should:

- Contain a workflow named `11-inputs - Build Nginx image`.
- Be triggered manually via `workflow_dispatch` with five inputs:
  - `image_name` (string)
  - `app_env` (choice: `dev`, `staging`, `prod`)
  - `build_number` (number)
  - `push_image` (boolean)
  - `deploy_environment` (environment)
- Define default Bash shell and working directory `./CWICZENIA/11-inputs`.
- Have one job `build-and-optional-push` that:
  - Runs on `ubuntu-latest`.
  - Uses the environment specified by `deploy_environment`.
  - Has permissions `contents: read`, `packages: write`, `id-token: write`.
  - Performs the steps:
    - Checkout repo
    - Print parameters
    - Build Docker image
    - Conditionally login to GHCR
    - Conditionally push the image

If all of the above is implemented, your workflow is logically equivalent to the reference solution.

---

# Ćwiczenie: Workflow GitHub Actions z inputami (Docker + GHCR) (PL)

## 1. Cel ćwiczenia (PL)

W tym ćwiczeniu utworzysz plik workflow GitHub Actions, który:

- Buduje obraz Dockera dla przykładowej aplikacji opartej o Nginx.
- Wykorzystuje wiele **typowanych inputów** (`string`, `choice`, `number`, `boolean`, `environment`) przekazywanych przez `workflow_dispatch`.
- Opcjonalnie wypycha zbudowany obraz do **GitHub Container Registry (GHCR)**.
- Używa **GitHub Environment**, wybieranego w momencie uruchomienia workflowa.

Efektem końcowym ma być plik YAML z workflowem, który jest logicznie i strukturalnie równoważny specyfikacji opisanej poniżej.

---

## 2. Plik i lokalizacja (PL)

1. W repozytorium upewnij się, że istnieje następująca struktura katalogów:
   - `.github/workflows/`

2. W tym katalogu utwórz nowy plik, np.:
   - `.github/workflows/11-inputs-build-nginx.yml`

3. Wszystkie kolejne kroki opisują, co dokładnie powinno znaleźć się w tym pliku (krok po kroku, blok po bloku).

---

## 3. Nagłówek workflow i trigger (PL)

### 3.1. Nazwa workflow

Na samej górze pliku dodaj nazwę workflow:

- Pole `name` ustaw na: `11-inputs - Build Nginx image`

Omówienie:

- `name:` — klucz najwyższego poziomu, decyduje, jak workflow będzie się nazywał w interfejsie GitHub Actions.
- `11-inputs - Build Nginx image` — opisowa nazwa sugerująca, że jest to ćwiczenie nr 11 oraz że workflow buduje obraz Nginx.

### 3.2. Konfiguracja triggera (`on:` + `workflow_dispatch`)

Pod nazwą workflow zdefiniuj blok określający, co uruchamia workflow. W tym ćwiczeniu workflow ma uruchamiać się **ręcznie** z parametrami:

1. Dodaj klucz `on:`.
2. Pod `on:` dodaj blok `workflow_dispatch:`.
3. Wewnątrz `workflow_dispatch:` umieść blok `inputs:` zawierający wszystkie wymienione niżej inputy.

Struktura powinna wyglądać ogólnie tak:

- `on:`
  - `workflow_dispatch:`
    - `inputs:`
      - `image_name: ...`
      - `app_env: ...`
      - `build_number: ...`
      - `push_image: ...`
      - `deploy_environment: ...`

Każdy input musi mieć określony typ, opis oraz odpowiednio `default` / `required`, zgodnie z następną sekcją.

---

## 4. Definicje inputów (PL)

Wewnątrz `on.workflow_dispatch.inputs` zdefiniuj następujące inputy.

### 4.1. `image_name` (string)

Dodaj input o nazwie `image_name`:

- `description`: `"Nazwa obrazu (bez tagu)"` (pozostaw opis dokładnie w tej formie).
- `type`: `string`
- `required`: `true`
- `default`: `"demo-nginx"`

Omówienie:

- Ten input pozwala użytkownikowi podać nazwę obrazu Dockera (bez tagu).
- Domyślnie, jeśli użytkownik nic nie zmieni, obraz będzie miał nazwę `demo-nginx`.

### 4.2. `app_env` (choice)

Dodaj input o nazwie `app_env`, który pozwala wybrać środowisko aplikacji:

- `description`: `"Środowisko aplikacji (wpływa na tag)"`
- `type`: `choice`
- `options`:
  - `dev`
  - `staging`
  - `prod`
- `default`: `dev`

Omówienie:

- `type: choice` — użytkownik wybiera wartość z predefiniowanej listy.
- Wybrana wartość będzie wykorzystana w tagu obrazu (np. `dev-1`, `prod-3` itd.).

### 4.3. `build_number` (number)

Dodaj input o nazwie `build_number`:

- `description`: `"Numer builda (dodawany do tagu)"`
- `type`: `number`
- `required`: `true`
- `default`: `1`

Omówienie:

- Ten input jest liczbowy i reprezentuje numer builda.
- Będzie dołączany do tagu, np. `dev-1`, `dev-2` itd.

### 4.4. `push_image` (boolean)

Dodaj input o nazwie `push_image`:

- `description`: `"Czy wypchnąć obraz do rejestru GHCR?"`
- `type`: `boolean`
- `default`: `false`

Omówienie:

- Jest to przełącznik typu prawda/fałsz.
- Gdy `true`, workflow zaloguje się do GHCR i wypchnie obraz.
- Gdy `false`, obraz zostanie tylko zbudowany lokalnie na runnerze.

### 4.5. `deploy_environment` (environment)

Dodaj input o nazwie `deploy_environment`:

- `description`: `"GitHub Environment (np. dev-env, staging-env, prod-env)"`
- `type`: `environment`
- `required`: `true`

Omówienie:

- Ten input pozwala wybrać **GitHub Environment** (np. `dev-env`, `staging-env`, `prod-env`) podczas uruchamiania workflowa.
- W kolejnej części wartość tego inputu zostanie użyta do ustawienia pola `environment:` w jobie.

---

## 5. Domyślne ustawienia dla kroków (PL)

Po sekcji `on:` dodaj na poziomie głównym blok `defaults:`, aby ustalić wspólne ustawienia dla wszystkich kroków typu `run`:

- `defaults:`
  - `run:`
    - `shell: bash`
    - `working-directory: ./CWICZENIA/11-inputs`

Omówienie każdej linii:

- `defaults:` — klucz top-level do definiowania wartości domyślnych dla kroków.
- `run:` — część dotycząca ustawień wykonywania skryptów.
- `shell: bash` — wszystkie polecenia w krokach `run` będą wykonywane w powłoce Bash.
- `working-directory: ./CWICZENIA/11-inputs` — każdy krok (jeśli nie nadpiszesz tego lokalnie) będzie wykonywany w tym katalogu.

Oznacza to, że kontekst Dockera (w tym Dockerfile) powinien znajdować się w `./CWICZENIA/11-inputs` względem katalogu głównego repozytorium.

---

## 6. Definicja joba (PL)

### 6.1. Nazwa joba i runner

1. Utwórz blok `jobs:` na poziomie głównym.
2. Wewnątrz zdefiniuj job o identyfikatorze `build-and-optional-push`.
3. W tym jobie ustaw:

   - `name: Build Docker image (11-inputs)`
   - `runs-on: ubuntu-latest`

Omówienie:

- `jobs:` — główny blok zawierający wszystkie joby.
- `build-and-optional-push:` — wewnętrzna nazwa joba (ID używane w konfiguracji).
- `name:` — czytelna nazwa joba wyświetlana w UI GitHub Actions.
- `runs-on: ubuntu-latest` — job będzie uruchamiany na najnowszym ubuntu runnerze GitHub.

### 6.2. Środowisko joba z inputu

Wewnątrz joba ustaw pole `environment:` w oparciu o input `deploy_environment`:

- `environment: ${{ inputs.deploy_environment }}`

Omówienie:

- Dzięki temu cały job zostanie przypisany do środowiska GitHub wybranego przy uruchomieniu workflowa.
- `${{ ... }}` to składnia wyrażeń GitHub Actions.

### 6.3. Uprawnienia (permissions)

Skonfiguruj uprawnienia joba:

- `permissions:`
  - `contents: read`
  - `packages: write`
  - `id-token: write`

Omówienie:

- `contents: read` — zezwala na odczyt zawartości repozytorium.
- `packages: write` — wymagane, aby móc wypychać obrazy do GHCR (rejestr pakietów).
- `id-token: write` — typowy zakres używany np. przy OIDC i environmentach.

---

## 7. Kroki w jobie (PL)

Wewnątrz joba dodaj blok `steps:`, a następnie poniższe kroki, w podanej kolejności.

### 7.1. Krok: Checkout repo

Najpierw pobierz kod repozytorium:

- `- name: Checkout repo`
- `uses: actions/checkout@v4`

Omówienie:

- `-` — nowy element listy `steps`.
- `name:` — nazwa kroku widoczna w logach.
- `uses:` — krok korzysta z gotowej akcji GitHub (tutaj oficjalna akcja checkout).

### 7.2. Krok: Wyświetlenie wybranych parametrów

Dodaj krok, który wypisze wszystkie wybrane inputy do logów:

- `- name: Pokaz wybrane parametry`
- `run: |`
  - `echo "Wybrane parametry uruchomienia:"`
  - `echo "  image_name      = ${{ inputs.image_name }}"`
  - `echo "  app_env         = ${{ inputs.app_env }}"`
  - `echo "  build_number    = ${{ inputs.build_number }}"`
  - `echo "  push_image      = ${{ inputs.push_image }}"`
  - `echo "  deploy_environment (GitHub) = ${{ inputs.deploy_environment }}"`

Omówienie:

- `run: |` — oznacza początek wieloliniowego skryptu Bash.
- Każde `echo` wypisuje aktualną wartość danego inputu – dzięki temu w logach wyraźnie widać, z jakimi parametrami workflow został uruchomiony.

### 7.3. Krok: Budowa obrazu Dockera

Dodaj krok, który buduje obraz Dockera na podstawie inputów:

- `- name: Build Docker image (z użyciem wszystkich inputów)`
- `run: |` i skrypt Bash, który:

  1. Przypisuje zmienne powłoki na podstawie inputów:
     - `IMAGE_NAME="${{ inputs.image_name }}"`
     - `APP_ENV="${{ inputs.app_env }}"`
     - `BUILD_NUMBER="${{ inputs.build_number }}"`

  2. Buduje tag obrazu na podstawie środowiska i numeru builda:
     - `IMAGE_TAG="${APP_ENV}-${BUILD_NUMBER}"`
       - np. `dev-1`, `staging-5`, `prod-10`.

  3. Konwertuje nazwę właściciela repozytorium na małe litery (wymóg GHCR):
     - `OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')`

  4. Składa pełny URI obrazu:
     - `IMAGE_URI="ghcr.io/${OWNER_LOWER}/${IMAGE_NAME}:${IMAGE_TAG}"`

  5. Wypisuje informacje pomocnicze:
     - `echo "Buduję obraz: ${IMAGE_URI}"`
     - `echo "Kontekst builda: $(pwd)"`

  6. Uruchamia `docker build` z argumentami build-time:
     - `docker build \`
       - `--build-arg APP_ENV="${APP_ENV}" \`
       - `--build-arg BUILD_NUMBER="${BUILD_NUMBER}" \`
       - `-t "${IMAGE_URI}" .`

  7. Na końcu informuje o gotowym obrazie lokalnym:
     - `echo "Gotowy lokalny obraz: ${IMAGE_URI}"`

Omówienie:

- Skrypt wykorzystuje inputy do zbudowania deterministycznej nazwy i tagu obrazu.
- Argumenty `--build-arg` (`APP_ENV`, `BUILD_NUMBER`) mogą być wykorzystane w Dockerfile.
- Obraz zostaje otagowany adresem zgodnym z GHCR.

### 7.4. Krok: Logowanie do GHCR (warunkowo)

Dodaj krok, który loguje się do GHCR **tylko wtedy**, gdy `push_image` ma wartość `true`:

- `- name: Login do GHCR`
- `if: ${{ inputs.push_image }}`
- `run: |`
  - `echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u "${{ github.actor }}" --password-stdin`

Omówienie:

- `if: ${{ inputs.push_image }}` — krok zostanie wykonany tylko wtedy, gdy input `push_image` jest ustawiony na `true`.
- `secrets.GITHUB_TOKEN` — wbudowany sekret GitHuba używany do autoryzacji w GHCR.
- `github.actor` — użytkownik lub aplikacja, która uruchomiła workflow.

### 7.5. Krok: Push obrazu Dockera (warunkowo)

Dodaj ostatni krok, który wypycha obraz do GHCR – również warunkowo:

- `- name: Push Docker image (tylko jeśli push_image == true)`
- `if: ${{ inputs.push_image }}`
- `run: |` ze skryptem, który:

  1. Odtwarza te same zmienne, co w kroku builda:
     - `IMAGE_NAME="${{ inputs.image_name }}"`
     - `APP_ENV="${{ inputs.app_env }}"`
     - `BUILD_NUMBER="${{ inputs.build_number }}"`
     - `IMAGE_TAG="${APP_ENV}-${BUILD_NUMBER}"`
     - `OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')`
     - `IMAGE_URI="ghcr.io/${OWNER_LOWER}/${IMAGE_NAME}:${IMAGE_TAG}"`

  2. Wypisuje informację o wypychanym obrazie:
     - `echo "Wypycham obraz: ${IMAGE_URI}"`

  3. Wypycha obraz:
     - `docker push "${IMAGE_URI}"`

Omówienie:

- Ten krok wykorzystuje tę samą logikę nadawania nazwy, dzięki czemu dokładnie ten zbudowany obraz zostaje wypchnięty.
- Krok zostanie pominięty, jeśli `push_image` = `false`.

---

## 8. Co powinno być na końcu (PL)

Po zrealizowaniu ćwiczenia, Twój plik `.github/workflows/...yml` powinien:

- Mieć workflow o nazwie `11-inputs - Build Nginx image`.
- Być uruchamiany ręcznie przez `workflow_dispatch` z pięcioma inputami:
  - `image_name` (string)
  - `app_env` (choice: `dev`, `staging`, `prod`)
  - `build_number` (number)
  - `push_image` (boolean)
  - `deploy_environment` (environment)
- Definiować domyślną powłokę Bash i katalog roboczy `./CWICZENIA/11-inputs`.
- Zawierać pojedynczy job `build-and-optional-push`, który:
  - Działa na `ubuntu-latest`,
  - Używa środowiska podanego przez `deploy_environment`,
  - Ma uprawnienia `contents: read`, `packages: write`, `id-token: write`,
  - Wykonuje kroki:
    - Checkout repozytorium,
    - Wypisanie parametrów,
    - Budowa obrazu Dockera,
    - Warunkowe logowanie do GHCR,
    - Warunkowy push obrazu.

Jeśli wszystkie powyższe elementy są obecne i działają zgodnie z opisem, Twój workflow jest równoważny rozwiązaniu referencyjnemu.

