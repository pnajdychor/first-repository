# Exercise: GitHub Actions Workflow with Step Outputs (Docker + Nginx)

## 1. Goal of the exercise (EN)

In this exercise you will create a GitHub Actions workflow file that:

- Builds a Docker image for an Nginx-based demo application.
- Runs a container from that image.
- Downloads a web page from the running container.
- Extracts the `<title>...</title>` from the HTML and exposes it as a **step output**.
- Reads and prints that output in a later step.

Your final result should be a workflow YAML file logically and structurally equivalent to the specification described below.

---

## 2. File and location (EN)

1. In your repository, ensure this folder exists:
   - `.github/workflows/`

2. Inside this folder, create or edit a workflow file, for example:
   - `.github/workflows/docker-nginx.yml`

3. All following steps describe what you must put into this file, block by block, so that it matches the intended behaviour.

---

## 3. Workflow header and triggers (EN)

### 3.1. Workflow name

At the top of the file, define a human-readable workflow name:

- `name: 12-outputs - Docker + Nginx`

Explanation:

- `name:` — top-level key that defines how the workflow is displayed in the GitHub Actions UI.
- `12-outputs - Docker + Nginx` — descriptive name indicating this is exercise 12 and that it works with Docker and Nginx, focusing on outputs.

### 3.2. Triggers (`on:`)

Under the name, define how the workflow is triggered using the `on:` key.

You must configure **two ways** to trigger it:

1. On `push`, but only when certain paths change.
2. Manually via `workflow_dispatch` (no inputs needed in this exercise).

The structure should look like:

```yaml
on:
  push:
    paths:
      - 'CWICZENIA/12-outputs/**'
      - '.github/workflows/docker-nginx.yml'
  workflow_dispatch:
```

Explanation of each part:

- `on:` — root key defining events that start the workflow.
- `push:` — the workflow runs when code is pushed to the repository.
- `paths:` — restricts the workflow to run only when files in these paths change:
  - `CWICZENIA/12-outputs/**` — any file under this directory.
  - `.github/workflows/docker-nginx.yml` — the workflow file itself.
- `workflow_dispatch:` — enables **manual** run from the GitHub UI (“Run workflow” button).

---

## 4. Job definition (EN)

After the `on:` block, define the job(s) to be run.

### 4.1. Single job: `build-and-test`

Add a `jobs:` top-level key and define one job named `build-and-test`:

```yaml
jobs:
  build-and-test:
    runs-on: ubuntu-latest
```

Explanation:

- `jobs:` — root key for all jobs.
- `build-and-test:` — job identifier (ID) used inside the workflow.
- `runs-on: ubuntu-latest` — job runs on GitHub’s latest Ubuntu runner with Docker preinstalled.

### 4.2. Default working directory for steps

Inside the `build-and-test` job, define default settings for `run` steps so that they use a specific working directory:

```yaml
    defaults:
      run:
        working-directory: CWICZENIA/12-outputs
```

Explanation of each line:

- `defaults:` — job-level defaults.
- `run:` — default settings for script steps.
- `working-directory: CWICZENIA/12-outputs` — by default, all `run:` commands will execute from this directory.

This means your Docker context (Dockerfile, HTML file, etc.) should be located under `CWICZENIA/12-outputs` in the repository.

---

## 5. Steps in the job (EN)

Now add a `steps:` block inside the job and define the sequence of actions to run.

```yaml
    steps:
      - ...
```

### 5.1. Step: Checkout repo

First step: check out the repository code so that Docker and scripts can access files.

```yaml
      - name: Checkout repo
        uses: actions/checkout@v4
```

Explanation:

- `-` — list item in `steps`.
- `name:` — human-readable name for the step in logs.
- `uses: actions/checkout@v4` — uses the official checkout action to get the repository content onto the runner.

### 5.2. Step: Build Docker image

Second step: build a Docker image with Nginx.

```yaml
      - name: Build Docker image
        run: |
          docker build -t my-nginx:github-actions .
```

Explanation:

- `run: |` — introduces a multi-line shell script (here only one command).
- `docker build -t my-nginx:github-actions .` — builds a Docker image from the current directory (`.`), tagging it as `my-nginx:github-actions`:
  - `-t my-nginx:github-actions` — sets the image name and tag.
  - The context is the working directory (`CWICZENIA/12-outputs`).

### 5.3. Step: Run container

Third step: run a container from the image in detached mode and open a port.

```yaml
      - name: Run container
        run: |
          # Uruchamiamy kontener w tle, mapujemy port 8080 hosta na 80 w kontenerze
          docker run -d --name my-nginx -p 8080:80 my-nginx:github-actions
          # Krótka pauza, żeby Nginx zdążył się podnieść
          sleep 5
```

Explanation:

- `docker run -d --name my-nginx -p 8080:80 my-nginx:github-actions`:
  - `-d` — run in the background (detached).
  - `--name my-nginx` — container name.
  - `-p 8080:80` — map host port 8080 to container port 80 where Nginx listens.
  - `my-nginx:github-actions` — image built in the previous step.
- `sleep 5` — wait a few seconds to ensure that Nginx has started and responds to HTTP requests.

### 5.4. Step: Download page from Nginx

Fourth step: request the web page from the running container and save it to a file.

```yaml
      - name: Download page from Nginx
        run: |
          # Pobieramy stronę z działającego kontenera
          curl -sS http://localhost:8080 > output.html
          echo "Zawartość pobranej strony:"
          cat output.html
```

Explanation:

- `curl -sS http://localhost:8080 > output.html`:
  - `curl` — HTTP client.
  - `-sS` — silent mode, but still show errors.
  - `http://localhost:8080` — address of the Nginx server exposed from the container.
  - `> output.html` — save the HTTP response body to the file `output.html`.
- `cat output.html` — print the downloaded HTML to the logs (for debugging and visibility).

### 5.5. Step: Extract title as step output

Fifth step: extract the `<title>` from `output.html` and expose it as an output of this step.

```yaml
      - name: Extract title as step output
        id: extract_title
        run: |
          # Wyciągamy zawartość <title>...</title> z HTML
          title=$(grep -oP '(?<=<title>).*?(?=</title>)' output.html || echo "brak tytułu")
          echo "Znaleziony tytuł: $title"
          # Ustawiamy OUTPUT kroku
          echo "page_title=$title" >> "$GITHUB_OUTPUT"
```

Explanation of each line:

- `id: extract_title` — assigns a unique ID to this step so later steps can reference its outputs as `steps.extract_title.outputs....`.
- `title=$(grep -oP '(?<=<title>).*?(?=</title>)' output.html || echo "brak tytułu")`:
  - `grep -oP` — uses Perl-compatible regex to extract matches.
  - `(?<=<title>).*(?=</title>)` — regex that captures the content between `<title>` and `</title>`.
  - `output.html` — file downloaded in the previous step.
  - `|| echo "brak tytułu"` — if `grep` finds nothing or fails, default to `"brak tytułu"`.
- `echo "Znaleziony tytuł: $title"` — log the found title.
- `echo "page_title=$title" >> "$GITHUB_OUTPUT"`:
  - This is the **official GitHub Actions way** to set a step output in new syntax.
  - `page_title` — the output name.
  - `$GITHUB_OUTPUT` — a special file path provided by the runner; writing `key=value` into it defines outputs for this step.

### 5.6. Step: Show step output

Sixth (final) step: use the value of the previously defined output and display it.

```yaml
      - name: Show step output
        run: |
          echo "Tytuł strony (z outputu kroku): ${{ steps.extract_title.outputs.page_title }}"
```

Explanation:

- `steps.extract_title.outputs.page_title`:
  - `steps` — access to previous steps.
  - `extract_title` — the `id` of the step where the output was defined.
  - `outputs.page_title` — the name of the output set via `$GITHUB_OUTPUT`.
- The `echo` command prints the page title read from the step output mechanism, demonstrating how step outputs can be used.

---

## 6. What you should have at the end (EN)

By the end of the exercise, your `.github/workflows/docker-nginx.yml` (or equivalent) should:

- Have this header:
  - `name: 12-outputs - Docker + Nginx`
- Be triggered by:
  - `push` events affecting `CWICZENIA/12-outputs/**` or `.github/workflows/docker-nginx.yml`.
  - Manual `workflow_dispatch` (no inputs required).
- Define a single job `build-and-test` that:
  - Runs on `ubuntu-latest`.
  - Has a default working directory `CWICZENIA/12-outputs` for `run` steps.
- Contains the steps:
  1. Checkout repository.
  2. Build the Docker image `my-nginx:github-actions`.
  3. Run an Nginx container on port 8080.
  4. Download the page to `output.html` and print it.
  5. Extract the `<title>` and set it as a step output `page_title` using `$GITHUB_OUTPUT`.
  6. Read `steps.extract_title.outputs.page_title` and display it.

If all the above works and the title is correctly printed from the output, your workflow is logically equivalent to the reference solution.

---

# Ćwiczenie: Workflow GitHub Actions z outputami kroków (Docker + Nginx) (PL)

## 1. Cel ćwiczenia (PL)

W tym ćwiczeniu utworzysz plik workflow GitHub Actions, który:

- Buduje obraz Dockera dla przykładowej aplikacji opartej o Nginx.
- Uruchamia kontener z tego obrazu.
- Pobiera stronę WWW z działającego kontenera.
- Wyciąga zawartość znacznika `<title>...</title>` z HTML i ustawia ją jako **output kroku**.
- W kolejnym kroku odczytuje i wyświetla ten output.

Efektem końcowym ma być plik YAML z workflowem, który jest logicznie i strukturalnie równoważny specyfikacji opisanej poniżej.

---

## 2. Plik i lokalizacja (PL)

1. W repozytorium upewnij się, że istnieje katalog:
   - `.github/workflows/`

2. W tym katalogu utwórz lub edytuj plik workflow, np.:
   - `.github/workflows/docker-nginx.yml`

3. Wszystkie kolejne kroki opisują dokładnie, co powinno znaleźć się w tym pliku, aby osiągnąć oczekiwane zachowanie.

---

## 3. Nagłówek workflow i triggery (PL)

### 3.1. Nazwa workflow

Na samej górze pliku ustaw nazwę workflow:

- `name: 12-outputs - Docker + Nginx`

Omówienie:

- `name:` — klucz najwyższego poziomu, który decyduje o tym, jak workflow nazywa się w interfejsie GitHuba.
- `12-outputs - Docker + Nginx` — nazwa sugerująca, że to ćwiczenie nr 12 i że dotyczy Dockera i Nginxa, z naciskiem na outputy kroków.

### 3.2. Konfiguracja triggerów (`on:`)

Pod nazwą zdefiniuj blok `on:`, określający, kiedy workflow ma się uruchamiać.

W tym ćwiczeniu workflow ma uruchamiać się na dwa sposoby:

1. Na `push`, ale tylko gdy zmienią się określone pliki.
2. Ręcznie poprzez `workflow_dispatch`.

Struktura powinna wyglądać tak:

```yaml
on:
  push:
    paths:
      - 'CWICZENIA/12-outputs/**'
      - '.github/workflows/docker-nginx.yml'
  workflow_dispatch:
```

Omówienie:

- `on:` — definicja zdarzeń uruchamiających workflow.
- `push:` — workflow uruchomi się przy wypchnięciu zmian do repozytorium.
- `paths:` — ogranicza uruchamianie workflowa tylko do sytuacji, gdy zmodyfikowane zostały pliki:
  - w katalogu `CWICZENIA/12-outputs/**`,
  - sam plik workflow `.github/workflows/docker-nginx.yml`.
- `workflow_dispatch:` — umożliwia ręczne uruchomienie workflowa z poziomu UI GitHuba (przycisk „Run workflow”).

---

## 4. Definicja joba (PL)

Po sekcji `on:` zdefiniuj job, który zostanie wykonany.

### 4.1. Pojedynczy job: `build-and-test`

Dodaj na poziomie głównym:

```yaml
jobs:
  build-and-test:
    runs-on: ubuntu-latest
```

Omówienie:

- `jobs:` — główny blok zawierający wszystkie joby.
- `build-and-test:` — identyfikator joba (używany wewnętrznie).
- `runs-on: ubuntu-latest` — job będzie wykonywany na runnerze z systemem Ubuntu (najnowsza dostępna wersja).

### 4.2. Domyślny katalog roboczy dla kroków

Wewnątrz `build-and-test` dodaj domyślne ustawienia dla kroków `run`:

```yaml
    defaults:
      run:
        working-directory: CWICZENIA/12-outputs
```

Omówienie:

- `defaults:` — domyślne ustawienia dla joba.
- `run:` — ustawienia dotyczące wykonywania skryptów.
- `working-directory: CWICZENIA/12-outputs` — wszystkie kroki `run` będą domyślnie wykonywane w tym katalogu.

Oznacza to, że kontekst Dockera (Dockerfile, pliki HTML itd.) powinien znajdować się w katalogu `CWICZENIA/12-outputs` w repozytorium.

---

## 5. Kroki w jobie (PL)

Dodaj blok `steps:` wewnątrz joba, a następnie kolejne kroki w odpowiedniej kolejności:

```yaml
    steps:
      - ...
```

### 5.1. Krok: Checkout repo

Pierwszy krok — pobranie kodu repozytorium:

```yaml
      - name: Checkout repo
        uses: actions/checkout@v4
```

Omówienie:

- `name:` — nazwa kroku widoczna w logach.
- `uses: actions/checkout@v4` — użycie oficjalnej akcji GitHuba do sklonowania repozytorium na runner.

### 5.2. Krok: Budowa obrazu Dockera

Drugi krok — budowa obrazu Dockera z Nginxem:

```yaml
      - name: Build Docker image
        run: |
          docker build -t my-nginx:github-actions .
```

Omówienie:

- `run: |` — wieloliniowy skrypt powłoki.
- `docker build -t my-nginx:github-actions .`:
  - buduje obraz Dockera na podstawie bieżącego katalogu (`.`),
  - `-t my-nginx:github-actions` — ustawia nazwę i tag obrazu.

### 5.3. Krok: Uruchomienie kontenera

Trzeci krok — uruchomienie kontenera na bazie zbudowanego obrazu:

```yaml
      - name: Run container
        run: |
          # Uruchamiamy kontener w tle, mapujemy port 8080 hosta na 80 w kontenerze
          docker run -d --name my-nginx -p 8080:80 my-nginx:github-actions
          # Krótka pauza, żeby Nginx zdążył się podnieść
          sleep 5
```

Omówienie:

- `docker run -d --name my-nginx -p 8080:80 my-nginx:github-actions`:
  - `-d` — uruchom w tle (detached),
  - `--name my-nginx` — nazwa kontenera,
  - `-p 8080:80` — mapowanie portu 8080 hosta na port 80 w kontenerze (gdzie nasłuchuje Nginx),
  - `my-nginx:github-actions` — obraz z poprzedniego kroku.
- `sleep 5` — krótkie opóźnienie, aby Nginx zdążył się uruchomić i zaczął obsługiwać zapytania HTTP.

### 5.4. Krok: Pobranie strony z Nginxa

Czwarty krok — pobranie strony z działającego kontenera:

```yaml
      - name: Download page from Nginx
        run: |
          # Pobieramy stronę z działającego kontenera
          curl -sS http://localhost:8080 > output.html
          echo "Zawartość pobranej strony:"
          cat output.html
```

Omówienie:

- `curl -sS http://localhost:8080 > output.html`:
  - `curl` — klient HTTP,
  - `-sS` — tryb cichy, ale z wyświetlaniem błędów,
  - `http://localhost:8080` — adres aplikacji wystawionej przez kontener,
  - `> output.html` — zapisanie treści odpowiedzi HTTP do pliku `output.html`.
- `cat output.html` — wypisanie zawartości pliku HTML w logach (pomocne do debugowania).

### 5.5. Krok: Wyciągnięcie tytułu jako output kroku

Piąty krok — wyciągnięcie zawartości `<title>...</title>` i ustawienie jej jako output kroku.

```yaml
      - name: Extract title as step output
        id: extract_title
        run: |
          # Wyciągamy zawartość <title>...</title> z HTML
          title=$(grep -oP '(?<=<title>).*?(?=</title>)' output.html || echo "brak tytułu")
          echo "Znaleziony tytuł: $title"
          # Ustawiamy OUTPUT kroku
          echo "page_title=$title" >> "$GITHUB_OUTPUT"
```

Omówienie:

- `id: extract_title` — unikalny identyfikator kroku, potrzebny do późniejszego odwoływania się do jego outputów.
- `title=$(grep -oP '(?<=<title>).*?(?=</title>)' output.html || echo "brak tytułu")`:
  - `grep -oP` — użycie wyrażeń regularnych w trybie Perl-compatible,
  - `(?<=<title>).*?(?=</title>)` — wzorzec wyciągający tekst pomiędzy `<title>` i `</title>`,
  - `output.html` — plik z pobraną stroną,
  - `|| echo "brak tytułu"` — jeśli nie uda się znaleźć tytułu, podstawia tekst `"brak tytułu"`.
- `echo "page_title=$title" >> "$GITHUB_OUTPUT"`:
  - `$GITHUB_OUTPUT` — specjalny plik wykorzystywany przez GitHub Actions do definiowania outputów kroków,
  - `page_title` — nazwa outputu,
  - zapis `klucz=wartość` do `$GITHUB_OUTPUT` rejestruje output kroku.

### 5.6. Krok: Wyświetlenie outputu kroku

Szósty (ostatni) krok — odczytanie i wyświetlenie wartości outputu `page_title`:

```yaml
      - name: Show step output
        run: |
          echo "Tytuł strony (z outputu kroku): ${{ steps.extract_title.outputs.page_title }}"
```

Omówienie:

- `${{ steps.extract_title.outputs.page_title }}`:
  - `steps` — dostęp do poprzednich kroków,
  - `extract_title` — identyfikator kroku, w którym zdefiniowano output,
  - `outputs.page_title` — nazwa outputu ustawiona przez `$GITHUB_OUTPUT`.
- `echo` wypisuje tytuł strony odczytany mechanizmem outputów kroków, demonstrując, jak można przekazywać dane między krokami w tym samym jobie.

---

## 6. Co powinno być na końcu (PL)

Po wykonaniu ćwiczenia Twój plik `.github/workflows/docker-nginx.yml` (lub równoważny) powinien:

- Mieć nagłówek:
  - `name: 12-outputs - Docker + Nginx`
- Być uruchamiany przez:
  - zdarzenia `push`, jeśli zostały zmienione pliki w `CWICZENIA/12-outputs/**` lub `.github/workflows/docker-nginx.yml`,
  - ręczne uruchomienie `workflow_dispatch`.
- Definiować pojedynczy job `build-and-test`, który:
  - działa na `ubuntu-latest`,
  - ma domyślny katalog roboczy `CWICZENIA/12-outputs` dla kroków `run`.
- Zawierać kroki:
  1. Checkout repozytorium,
  2. Budowa obrazu Dockera `my-nginx:github-actions`,
  3. Uruchomienie kontenera z mapowaniem portu 8080,
  4. Pobranie strony do pliku `output.html` i wypisanie jej zawartości,
  5. Wyciągnięcie zawartości `<title>` i ustawienie jej jako output `page_title` za pomocą `$GITHUB_OUTPUT`,
  6. Odczytanie `steps.extract_title.outputs.page_title` i wyświetlenie tytułu w logach.

Jeśli wszystkie powyższe elementy działają zgodnie z opisem, Twój workflow jest równoważny rozwiązaniu referencyjnemu i poprawnie demonstruje użycie outputów kroków w GitHub Actions.

