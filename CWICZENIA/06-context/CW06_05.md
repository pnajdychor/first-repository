# Task: GitHub Actions – Build & Release Weather Binary (Python Package)

## Goal

You are given a repository containing a Python script for fetching weather information (e.g. `start.py`) in the directory:

```text
./CWICZENIA/06-context/pogoda_python
```

Your goal is to create a **GitHub Actions workflow** (YAML file) that:

- Can be triggered manually.
- Builds a single-file binary from the Python script using **PyInstaller**.
- Optionally runs the generated binary and writes its output into the GitHub Actions **Step Summary**.
- Uploads the binary as a workflow artifact.
- Creates a **GitHub Release** and attaches the built binary to that release.

The final deliverable is a **single GitHub Actions workflow YAML file** in the repository.

---

## Part 1 – Prepare the workflow file

1. Open the repository locally in your editor (e.g. VS Code).
2. Ensure the following directory structure exists in the repository root:

   ```text
   .github/workflows
   ```

   If it does not exist, create it.
3. Inside `.github/workflows`, create a new file, for example:

   ```text
   06-05-contexts-pogoda_python_package.yaml
   ```

   This file will contain the complete workflow definition.

---

## Part 2 – Define workflow name, run name and trigger

4. At the top of the YAML file, add:

   - A **workflow name**, for example:  
     `06-05 - Package Pogoda Info Python`
   - A **run-name** that includes the chosen city dynamically, e.g.:  
     `06-05 - Package Python Pogoda dla ${{ inputs.city }}`

   These values control how the workflow and its runs are displayed in the GitHub Actions UI.

5. Configure manual triggering using `workflow_dispatch` and define two input parameters:

   - `city` (string)
     - `description`: e.g. `"City to get weather info for"`
     - `default`: `"Warsaw"`
   - `release_tag` (string)
     - `description`: e.g. `"Tag / wersja releasu (np. v1.0.0)"`
     - `default`: `"v0.1.0"`

   This will create a UI form where the user can specify the city and release tag when starting the workflow manually.

---

## Part 3 – Permissions and environment variable

6. Add a **permissions** section at the top level of the workflow:

   - Set `contents: write` so the workflow is allowed to create a GitHub Release and upload assets.

   Example structure (do not copy exact YAML, just match the meaning):

   ```yaml
   permissions:
     contents: write
   ```

7. Add a top-level `env` section with a variable that holds the API key:

   - Variable name: `MY_KLUCZYK`.
   - Value: for the exercise, you may use a visible test key; in real projects this should be moved to GitHub Secrets.

   Example structure:

   ```yaml
   env:
     MY_KLUCZYK: "YOUR_WEATHER_API_KEY"
   ```

---

## Part 4 – Define the job and defaults

8. Under `jobs`, define a job with ID `pogoda-info`.

9. Configure the job with:

   - `name`: a descriptive job name, e.g.  
     `Pobierz informacje o pogodzie + build binarki`
   - `runs-on`: `ubuntu-latest` so it runs on a Linux GitHub-hosted runner.

10. Inside the job, set **defaults** for the shell and working directory:

    - `shell`: `bash`
    - `working-directory`: `./CWICZENIA/06-context/pogoda_python`

    This ensures that all `run` steps use Bash and execute from the directory that contains `start.py`.

---

## Part 5 – Define the steps

11. Add a `steps` section to the `pogoda-info` job.

### Step 1 – Checkout repository

12. First, check out the repository:

    - Use the official action `actions/checkout@v4`.
    - Give the step a clear name such as `Checkout repository`.

    This step is required for the runner to access the project files and the Python script.

### Step 2 – Setup Python

13. Add a step to install a specific Python version:

    - Use `actions/setup-python@v5`.
    - Configure it with:
      - `python-version: "3.12"`

    This ensures that all subsequent Python commands use Python 3.12.

### Step 3 – Install build dependencies

14. Add a step that:

    - Upgrades `pip`.
    - Installs `pyinstaller`.

    For example, in the `run` section you should:

    - Call `python -m pip install --upgrade pip`
    - Call `pip install pyinstaller`

    This prepares the environment for building a standalone binary from the Python script.

### Step 4 – Build binary with PyInstaller

15. Add a step that uses **PyInstaller** to create a single-file binary from `start.py`:

    - Use a `run` block that calls PyInstaller with:
      - `--onefile` to create a single executable file.
      - `--name pogoda` to set the output binary name to `pogoda`.

    As a result, PyInstaller should produce a binary file:

    ```text
    ./dist/pogoda
    ```

    (relative to the working directory `./CWICZENIA/06-context/pogoda_python`).

### Step 5 – (Optional) Run the binary and append result to step summary

16. Add a step that:

    - Executes the generated binary from the `dist` folder.
    - Passes two parameters:
      1. The city from the input (`${{ inputs.city }}`).
      2. The API key from the environment (`${{ env.MY_KLUCZYK }}`).
    - Appends the output of the binary to the special file `$GITHUB_STEP_SUMMARY` using `>>`.

    Conceptually, the command in the `run` block should be equivalent to:

    ```bash
    ./dist/pogoda "${{ inputs.city }}" "${{ env.MY_KLUCZYK }}" >> "$GITHUB_STEP_SUMMARY"
    ```

    Mark this step as optional in the step name if you want, but it should be present and correctly configured.

### Step 6 – Upload binary as workflow artifact

17. Add a step that uploads the built binary as an artifact:

    - Use `actions/upload-artifact@v4`.
    - Configure:
      - `name`: a descriptive name, e.g. `pogoda-linux-amd64`.
      - `path`: the path to the binary created by PyInstaller, e.g.  
        `./CWICZENIA/06-context/pogoda_python/dist/pogoda`

    This allows downloading the built binary from the Actions run artifacts section.

### Step 7 – Create GitHub Release and upload the binary

18. Add a final step that:

    - Uses the action `softprops/action-gh-release@v2`.
    - Creates or updates a GitHub Release with:
      - `tag_name`: value taken from the `release_tag` input (`${{ inputs.release_tag }}`).
      - `name`: a human-readable release name, e.g. `"Pogoda binary ${{ inputs.release_tag }}"`.
      - `draft`: `false`.
      - `prerelease`: `false`.
      - `files`: path to the built binary:
        `./CWICZENIA/06-context/pogoda_python/dist/pogoda`
    - Uses the automatically provided GitHub token:
      - Under `env`, set `GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}` so the action can publish the release and upload files.

    This step ensures that every workflow run produces a GitHub Release tagged with the provided version and containing the built weather binary.

---

## Part 6 – Commit, push, and test

19. Save the YAML file in `.github/workflows/`.

20. Commit and push the file to the repository:

    ```bash
    git add .github/workflows/06-05-contexts-pogoda_python_package.yaml
    git commit -m "Add workflow to build and release weather binary"
    git push
    ```

21. In the GitHub web interface:

    - Go to the **Actions** tab.
    - Select your newly created workflow by its name.
    - Click **Run workflow**.
    - Fill in:
      - `city`: any city (or use the default).
      - `release_tag`: e.g. `v0.1.0` or another version.
    - Run the workflow.

22. After the run finishes, verify:

    - The job `pogoda-info` completed successfully.
    - The artifact `pogoda-linux-amd64` is available and contains the binary.
    - A GitHub Release with the specified `release_tag` was created and contains the uploaded binary file.

---

## Deliverable

Your final deliverable is the **GitHub Actions workflow YAML file** located at:

```text
.github/workflows/06-05-contexts-pogoda_python_package.yaml
```

It must implement **all** of the configuration described above: manual inputs, permissions, environment variable, PyInstaller build, optional binary execution with summary output, artifact upload, and GitHub Release creation with the built binary attached.

---

# Zadanie: GitHub Actions – Budowanie i wydawanie binarki pogodowej (Python Package)

## Cel

Otrzymujesz repozytorium zawierające skrypt Pythona do pobierania informacji o pogodzie (np. `start.py`) w katalogu:

```text
./CWICZENIA/06-context/pogoda_python
```

Twoim celem jest utworzenie **workflow GitHub Actions** (pliku YAML), który:

- Może być uruchamiany ręcznie.
- Buduje jednoplikiową binarkę ze skryptu Pythona przy użyciu **PyInstaller**.
- Opcjonalnie uruchamia wygenerowaną binarkę i zapisuje wynik do **Step Summary** w GitHub Actions.
- Przesyła binarkę jako artefakt workflow.
- Tworzy **GitHub Release** i dołącza do niego wygenerowaną binarkę.

Końcowym wynikiem jest **jeden plik YAML workflow** w repozytorium.

---

## Część 1 – Przygotowanie pliku workflow

1. Otwórz repozytorium lokalnie w edytorze (np. VS Code).
2. Upewnij się, że w katalogu głównym istnieje struktura:

   ```text
   .github/workflows
   ```

   Jeżeli nie istnieje, utwórz ją.
3. Wewnątrz `.github/workflows` utwórz nowy plik, np.:

   ```text
   06-05-contexts-pogoda_python_package.yaml
   ```

   Ten plik będzie zawierał pełną definicję workflow.

---

## Część 2 – Nazwa workflow, run-name i wyzwalacz

4. Na początku pliku YAML zdefiniuj:

   - **name** – nazwę workflow, np.:  
     `06-05 - Package Pogoda Info Python`
   - **run-name** – nazwę uruchomienia, która dynamicznie zawiera wybrane miasto, np.:  
     `06-05 - Package Python Pogoda dla ${{ inputs.city }}`

   Te wartości określają, jak workflow i jego uruchomienia będą prezentowane w GitHub Actions.

5. Skonfiguruj ręczne uruchamianie workflow za pomocą `workflow_dispatch` i zdefiniuj dwa parametry wejściowe:

   - `city` (string)
     - `description`: np. `"City to get weather info for"`
     - `default`: `"Warsaw"`
   - `release_tag` (string)
     - `description`: np. `"Tag / wersja releasu (np. v1.0.0)"`
     - `default`: `"v0.1.0"`

   Dzięki temu przy ręcznym uruchamianiu workflow w UI GitHuba pojawi się formularz z polami `city` i `release_tag`.

---

## Część 3 – Uprawnienia i zmienna środowiskowa

6. Dodaj sekcję **permissions** na najwyższym poziomie pliku YAML:

   - Ustaw `contents: write`, aby workflow mógł tworzyć GitHub Release i przesyłać pliki.

   Przykładowa struktura (dopasuj ją do swojego workflow):

   ```yaml
   permissions:
     contents: write
   ```

7. Dodaj sekcję `env` na poziomie całego workflow ze zmienną przechowującą klucz API:

   - Nazwa zmiennej: `MY_KLUCZYK`.
   - Wartość: na potrzeby ćwiczenia może być jawnie wpisana; w prawdziwym projekcie powinna zostać przeniesiona do GitHub Secrets.

   Przykład:

   ```yaml
   env:
     MY_KLUCZYK: "TWOJ_KLUCZ_API"
   ```

---

## Część 4 – Definicja joba i defaults

8. W sekcji `jobs` zdefiniuj job o identyfikatorze `pogoda-info`.

9. Skonfiguruj job:

   - `name`: opisowa nazwa, np.  
     `Pobierz informacje o pogodzie + build binarki`
   - `runs-on`: `ubuntu-latest`, aby job działał na maszynie Linux hostowanej przez GitHuba.

10. Wewnątrz joba skonfiguruj sekcję `defaults.run`:

    - `shell`: `bash`
    - `working-directory`: `./CWICZENIA/06-context/pogoda_python`

    Dzięki temu wszystkie kroki z `run`:

    - Będą wykonywane w powłoce Bash.
    - Będą uruchamiane z katalogu, w którym znajduje się `start.py`.

---

## Część 5 – Definicja kroków

11. Dodaj sekcję `steps` w jobie `pogoda-info`.

### Krok 1 – Checkout repozytorium

12. Najpierw pobierz zawartość repozytorium:

    - Użyj akcji `actions/checkout@v4`.
    - Nadaj krokowi czytelną nazwę, np. `Checkout repository`.

    Ten krok jest niezbędny, aby runner miał dostęp do kodu i skryptu Pythona.

### Krok 2 – Konfiguracja Pythona

13. Dodaj krok instalujący odpowiednią wersję Pythona:

    - Użyj akcji `actions/setup-python@v5`.
    - Skonfiguruj:
      - `python-version: "3.12"`

    Dzięki temu wszystkie polecenia Pythona będą korzystały z wersji 3.12.

### Krok 3 – Instalacja zależności build

14. Dodaj krok, który:

    - Aktualizuje `pip`.
    - Instaluje `pyinstaller`.

    W bloku `run` wykonaj m.in.:

    - `python -m pip install --upgrade pip`
    - `pip install pyinstaller`

    Przygotuje to środowisko do zbudowania binarki ze skryptu Pythona.

### Krok 4 – Budowanie binarki przy użyciu PyInstaller

15. Dodaj krok, który przy użyciu **PyInstaller** zbuduje jednoplikiową binarkę z `start.py`:

    - W `run` wywołaj PyInstaller z parametrami:
      - `--onefile` – tworzy pojedynczy plik wykonywalny.
      - `--name pogoda` – ustawia nazwę wyjściowej binarki na `pogoda`.

    W efekcie PyInstaller powinien utworzyć plik binarny:

    ```text
    ./dist/pogoda
    ```

    (względem katalogu roboczego `./CWICZENIA/06-context/pogoda_python`).

### Krok 5 – (Opcjonalnie) Uruchomienie binarki i zapis do Step Summary

16. Dodaj krok, który:

    - Uruchamia wygenerowaną binarkę z katalogu `dist`.
    - Przekazuje do niej dwa argumenty:
      1. Miasto z wejścia workflow (`${{ inputs.city }}`).
      2. Klucz API ze zmiennej środowiskowej (`${{ env.MY_KLUCZYK }}`).
    - Dopisuje wynik działania programu do pliku `$GITHUB_STEP_SUMMARY` przy użyciu operatora `>>`.

    Logika polecenia w `run` powinna być równoważna:

    ```bash
    ./dist/pogoda "${{ inputs.city }}" "${{ env.MY_KLUCZYK }}" >> "$GITHUB_STEP_SUMMARY"
    ```

    W nazwie kroku możesz zaznaczyć, że jest „opcjonalny”, ale sam krok powinien być obecny i poprawnie skonfigurowany.

### Krok 6 – Przesłanie binarki jako artefakt

17. Dodaj krok przesyłający zbudowaną binarkę jako artefakt:

    - Użyj akcji `actions/upload-artifact@v4`.
    - Skonfiguruj:
      - `name`: np. `pogoda-linux-amd64`.
      - `path`: ścieżka do wygenerowanej binarki, np.  
        `./CWICZENIA/06-context/pogoda_python/dist/pogoda`

    Dzięki temu z poziomu uruchomienia workflow będziesz mógł pobrać gotową binarkę.

### Krok 7 – Utworzenie GitHub Release i załadowanie binarki

18. Dodaj końcowy krok, który:

    - Używa akcji `softprops/action-gh-release@v2`.
    - Tworzy lub aktualizuje Release na GitHubie z:
      - `tag_name`: wartością z wejścia `release_tag` (`${{ inputs.release_tag }}`).
      - `name`: nazwą releasu, np. `"Pogoda binary ${{ inputs.release_tag }}"`.
      - `draft`: `false`.
      - `prerelease`: `false`.
      - `files`: ścieżką do zbudowanej binarki:
        `./CWICZENIA/06-context/pogoda_python/dist/pogoda`
    - Korzysta z automatycznie dostarczonego tokenu GitHuba:
      - W sekcji `env` ustaw `GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}`, aby akcja mogła tworzyć release i przesyłać pliki.

    Dzięki temu każde uruchomienie workflow tworzy Release z podanym `release_tag` i dołączoną binarką pogodową.

---

## Część 6 – Commit, push i test

19. Zapisz plik YAML w katalogu `.github/workflows/`.

20. Wykonaj commit i push pliku do repozytorium:

    ```bash
    git add .github/workflows/06-05-contexts-pogoda_python_package.yaml
    git commit -m "Dodaj workflow do budowania i wydawania binarki pogodowej"
    git push
    ```

21. W interfejsie GitHuba:

    - Przejdź do zakładki **Actions**.
    - Wybierz utworzony workflow po jego nazwie.
    - Kliknij **Run workflow**.
    - Uzupełnij:
      - `city`: dowolne miasto (lub użyj domyślnego).
      - `release_tag`: np. `v0.1.0` lub inną wersję.
    - Uruchom workflow.

22. Po zakończeniu działania sprawdź:

    - Czy job `pogoda-info` zakończył się sukcesem.
    - Czy artefakt `pogoda-linux-amd64` jest dostępny i zawiera binarkę.
    - Czy został utworzony GitHub Release z podanym `release_tag` i dołączoną binarką.

---

## Rezultat

Końcowym rezultatem zadania jest **plik YAML workflow**:

```text
.github/workflows/06-05-contexts-pogoda_python_package.yaml
```

Plik musi zawierać wszystkie opisane elementy: wejścia `city` i `release_tag`, sekcję `permissions` z `contents: write`, zmienną `env.MY_KLUCZYK`, budowanie binarki PyInstallerem, opcjonalne uruchomienie programu z zapisaniem wyniku do podsumowania, przesłanie artefaktu oraz utworzenie GitHub Release z dołączoną binarką.
