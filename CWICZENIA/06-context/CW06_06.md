# Task: GitHub Actions CI for Weather API (Docker + FastAPI)

## Goal

You are given a small FastAPI-based weather API project located in:

```text
CWICZENIA/06-context/pogoda_python_flusk
```

This directory contains, among others:

- `app.py` – FastAPI application exposing a `/weather` endpoint.
- `requirements.txt` – Python dependencies (FastAPI, Uvicorn, etc.).
- `Dockerfile` – definition of the Docker image for the API.
- `start.py` – supporting script used by the application (e.g. to call OpenWeather).

Your goal is to create a **GitHub Actions workflow** (YAML file) that:

1. Builds and tests the Dockerized API on every change to specific branches and on pull requests.
2. Runs the container locally on the GitHub runner and calls the `/weather` endpoint using `curl`.
3. Cleans up the container after the tests.
4. On pushes to the `main` branch only:
   - Logs in to Docker Hub using secrets.
   - Tags the local image with two tags:
     - `latest`
     - a short commit SHA (first 7 characters)
   - Pushes both tags to Docker Hub.

The final deliverable is a **single GitHub Actions workflow YAML file** located under:

```text
.github/workflows/06-06-app-pogoda.yaml
```

---

## Part 1 – Project structure and context

1. Open the repository in your editor (VS Code or similar).
2. Locate the directory:

   ```text
   CWICZENIA/06-context/pogoda_python_flusk
   ```

   Inside it, you should find:
   - `app.py`
   - `requirements.txt`
   - `Dockerfile`
   - `start.py`
3. Review the files briefly:
   - `requirements.txt` contains at least:
     - `requests`
     - `fastapi`
     - `uvicorn[standard]`
   - `Dockerfile` is prepared to:
     - Install dependencies from `requirements.txt`.
     - Run the FastAPI app behind Uvicorn on port `8000`.
   - `app.py` exposes an HTTP GET endpoint `/weather` that expects query parameters such as `city` and `api_key`.

You do **not** need to modify these files as part of this task. Your responsibility is to automate build, test and image publishing using GitHub Actions.

---

## Part 2 – Create the workflow file

4. Ensure the following directory structure exists in the repository root:

   ```text
   .github/workflows
   ```

   If it does not exist, create it.
5. Inside `.github/workflows`, create a new file:

   ```text
   06-06-app-pogoda.yaml
   ```

   This file will hold the complete CI workflow definition.

---

## Part 3 – Workflow name and triggers

6. At the top of the YAML file, define a **workflow name**, for example:

   ```yaml
   name: "06-06 Pogoda API CI"
   ```

7. Configure the workflow to be triggered in three situations:

   - On `push` to the branches:
     - `feature/06-pogoda-api`
     - `main`
   - On `pull_request` targeting the branch:
     - `feature/06-pogoda-api`
   - Manually, via `workflow_dispatch`.

   The trigger section should conceptually:

   - Include a `push` block with `branches: [ feature/06-pogoda-api, main ]`.
   - Include a `pull_request` block with `branches: [ feature/06-pogoda-api ]`.
   - Include a `workflow_dispatch` block without additional inputs (manual run without parameters).

This ensures that the CI runs automatically on relevant branches and pull requests, but can also be started manually if needed.

---

## Part 4 – Define the job and environment

8. Under the `jobs` section, create a job with an identifier such as `build-and-test`:

   ```yaml
   jobs:
     build-and-test:
       runs-on: ubuntu-latest
   ```

9. In this job, define two environment variables under `env`:

   - `LOCAL_IMAGE_NAME`: name of the local Docker image used for testing, e.g. `python_pogoda:test`.
   - `WORKDIR`: relative path to the API application directory, i.e. `./CWICZENIA/06-context/pogoda_python_flusk`.

   Conceptually:

   ```yaml
   env:
     LOCAL_IMAGE_NAME: python_pogoda:test
     WORKDIR: ./CWICZENIA/06-context/pogoda_python_flusk
   ```

These environment variables will be used in subsequent steps to build and run the Docker image.

---

## Part 5 – Steps for build and test

10. Add a `steps` section inside the `build-and-test` job.

### Step 1 – Checkout repository

11. First, check out the repository code:

    - Use `actions/checkout@v4`.
    - Give the step a clear name like `Checkout repository`.

    This makes all repository files, including `app.py`, `Dockerfile`, `requirements.txt`, and `start.py`, available on the runner.

### Step 2 – Build Docker image for local testing

12. Add a step that builds a local Docker image using the `Dockerfile` from `WORKDIR`:

    - Use a shell command `docker build`.
    - Tag the image with the name from `LOCAL_IMAGE_NAME`.
    - Use the directory from `WORKDIR` as the build context.

    Conceptually, the command should look like:

    ```bash
    docker build -t "$LOCAL_IMAGE_NAME" "$WORKDIR"
    ```

### Step 3 – Run the container

13. Add a step that starts a container from the built image:

    - Use `docker run -d` to start the container in detached mode.
    - Give the container a name, e.g. `pogoda_api`.
    - Map host port `8000` to container port `8000` using `-p 8000:8000`.
    - Pass an environment variable `OPENWEATHER_API_KEY` into the container.
      - The value must come from a GitHub secret: `${{ secrets.OPENWEATHER_API_KEY }}`.
    - Use `"$LOCAL_IMAGE_NAME"` as the image name.

    Conceptual command:

    ```bash
    docker run -d       --name pogoda_api       -p 8000:8000       -e OPENWEATHER_API_KEY="${{ secrets.OPENWEATHER_API_KEY }}"       "$LOCAL_IMAGE_NAME"
    ```

    > Before using this workflow, you must configure the secret `OPENWEATHER_API_KEY` in the repository settings.

### Step 4 – Wait for API to start

14. Add a step that gives the API a few seconds to start before testing it:

    - Use `sleep 10`.
    - Optionally print an informational message to the log.

    Example:

    ```bash
    echo "Waiting for API to start..."
    sleep 10
    ```

### Step 5 – Test `/weather` endpoint using curl

15. Add a step that calls the `/weather` endpoint using `curl`:

    - Enable `set -e` so the script fails on the first error.
    - Use `curl -f` so that non-2xx responses cause a non-zero exit code.
    - Call the endpoint on `http://localhost:8000/weather`.
    - Pass query parameters:
      - `city=Warsaw`
      - `api_key` – again from `${{ secrets.OPENWEATHER_API_KEY }}`.

    Conceptual command:

    ```bash
    set -e
    echo "Testing /weather endpoint..."
    curl -f "http://localhost:8000/weather?city=Warsaw&api_key=${{ secrets.OPENWEATHER_API_KEY }}"
    echo
    echo "OK - /weather endpoint returned 2xx."
    ```

If the endpoint is not available or returns an error, this step should cause the job to fail.

### Step 6 – Show container logs on failure (debug)

16. Add a step that prints Docker logs for debugging **only when the job fails**:

    - Use `if: failure()` on the step.
    - Using `docker logs pogoda_api` to display logs.
    - Use `|| true` to prevent the step from failing if the container does not exist.

    Conceptual script:

    ```bash
    echo "Container logs:"
    docker logs pogoda_api || true
    ```

### Step 7 – Stop and remove the container (always)

17. Add a cleanup step that **always** stops and removes the `pogoda_api` container:

    - Use `if: always()` on the step.
    - Use `docker stop` and `docker rm` with `|| true` to avoid failing if the container is already stopped/removed.

    Example:

    ```bash
    docker stop pogoda_api || true
    docker rm pogoda_api || true
    ```

This ensures that the GitHub runner is left clean after each run.

---

## Part 6 – Docker Hub push for main branch

18. The remaining steps should only execute when:

    - The event is `push`, **and**
    - The branch is `main`.

    Use an `if` condition of the form:

    ```yaml
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    ```

### Step 8 – Log in to Docker Hub

19. Add a step that logs in to Docker Hub:

    - Use the official GitHub Action: `docker/login-action@v3`.
    - Provide:
      - `username`: `${{ secrets.DOCKERHUB_USERNAME }}`
      - `password`: `${{ secrets.DOCKERHUB_TOKEN }}`

    > Before running the workflow, configure the secrets `DOCKERHUB_USERNAME` and `DOCKERHUB_TOKEN` in the repository settings.

### Step 9 – Tag image for Docker Hub

20. Add a step that prepares tags for the Docker Hub image:

    - Compute a short SHA:

      ```bash
      SHORT_SHA="${GITHUB_SHA::7}"
      ```

    - Construct the base image name on Docker Hub using the username secret, e.g.:

      ```bash
      HUB_IMAGE_BASE="${{ secrets.DOCKERHUB_USERNAME }}/python_pogoda"
      ```

    - Tag the local image (`$LOCAL_IMAGE_NAME`) twice:
      - `$HUB_IMAGE_BASE:latest`
      - `$HUB_IMAGE_BASE:$SHORT_SHA`

    Conceptual script:

    ```bash
    SHORT_SHA="${GITHUB_SHA::7}"
    HUB_IMAGE_BASE="${{ secrets.DOCKERHUB_USERNAME }}/python_pogoda"

    echo "Tagging image:"
    echo " - $HUB_IMAGE_BASE:latest"
    echo " - $HUB_IMAGE_BASE:$SHORT_SHA"

    docker tag "$LOCAL_IMAGE_NAME" "$HUB_IMAGE_BASE:latest"
    docker tag "$LOCAL_IMAGE_NAME" "$HUB_IMAGE_BASE:$SHORT_SHA"
    ```

### Step 10 – Push image to Docker Hub

21. Add the final step that pushes both tags to Docker Hub:

    - Use `docker push` for:
      - `$HUB_IMAGE_BASE:latest`
      - `$HUB_IMAGE_BASE:$SHORT_SHA`

    Example:

    ```bash
    SHORT_SHA="${GITHUB_SHA::7}"
    HUB_IMAGE_BASE="${{ secrets.DOCKERHUB_USERNAME }}/python_pogoda"

    docker push "$HUB_IMAGE_BASE:latest"
    docker push "$HUB_IMAGE_BASE:$SHORT_SHA"
    ```

At this point, after a successful run on the `main` branch, the Docker image for the weather API will be published on Docker Hub with two tags: `latest` and the short commit SHA.

---

## Part 7 – Commit, push, and verify

22. Save the workflow file:

    ```text
    .github/workflows/06-06-app-pogoda.yaml
    ```

23. Commit and push the changes:

    ```bash
    git add .github/workflows/06-06-app-pogoda.yaml
    git commit -m "Add CI workflow for Dockerized weather API"
    git push
    ```

24. Verify the workflow:

    - For feature branch:
      - Create or update the branch `feature/06-pogoda-api`.
      - Push changes and observe the workflow run under **Actions**.
    - For a pull request:
      - Open a PR targeting `feature/06-pogoda-api`.
      - Check that the workflow runs automatically.
    - For the main branch:
      - Merge or push into `main`.
      - Confirm that:
        - The Docker image is built and tested.
        - The image is pushed to Docker Hub with the expected tags.

---

## Deliverable

Your final deliverable is the **GitHub Actions workflow YAML file**:

```text
.github/workflows/06-06-app-pogoda.yaml
```

It must implement:

- The specified triggers (`push`, `pull_request`, `workflow_dispatch`).
- A job `build-and-test` running on `ubuntu-latest`.
- Environment variables `LOCAL_IMAGE_NAME` and `WORKDIR`.
- Steps to:
  - Check out the code.
  - Build the Docker image with the provided `Dockerfile`.
  - Run the container with `OPENWEATHER_API_KEY` from secrets.
  - Wait for the API to start.
  - Test the `/weather` endpoint using `curl`.
  - Show logs on failure.
  - Always stop and remove the container.
- Additional steps (only on push to `main`) to:
  - Log in to Docker Hub.
  - Tag the local image with `latest` and short SHA.
  - Push both tags to Docker Hub.

---

# Zadanie: GitHub Actions CI dla pogodowego API (Docker + FastAPI)

## Cel

Otrzymujesz niewielki projekt pogodowego API opartego na FastAPI, znajdujący się w katalogu:

```text
CWICZENIA/06-context/pogoda_python_flusk
```

W tym katalogu znajdują się m.in.:

- `app.py` – aplikacja FastAPI wystawiająca endpoint `/weather`.
- `requirements.txt` – zależności Pythona (FastAPI, Uvicorn itp.).
- `Dockerfile` – definicja obrazu Dockera dla API.
- `start.py` – pomocniczy skrypt wykorzystywany przez aplikację (np. do wywołań OpenWeather).

Twoim zadaniem jest utworzenie **workflow GitHub Actions** (pliku YAML), który:

1. Buduje i testuje zdokeryzowane API przy każdej zmianie na odpowiednich gałęziach oraz dla pull requestów.
2. Uruchamia kontener lokalnie na runnerze GitHuba i wywołuje endpoint `/weather` przy użyciu `curl`.
3. Sprząta po sobie (zatrzymuje i usuwa kontener).
4. Dla pushy na gałąź `main`:
   - Loguje się do Docker Huba z użyciem sekretów.
   - Taguje lokalny obraz dwoma tagami:
     - `latest`
     - skróconym SHA commita (pierwsze 7 znaków)
   - Wypycha oba tagi do Docker Huba.

Końcowym rezultatem jest **jeden plik YAML workflow** umieszczony w:

```text
.github/workflows/06-06-app-pogoda.yaml
```

---

## Część 1 – Struktura projektu i kontekst

1. Otwórz repozytorium w edytorze (np. VS Code).
2. Znajdź katalog:

   ```text
   CWICZENIA/06-context/pogoda_python_flusk
   ```

   W środku powinny znajdować się m.in.:
   - `app.py`
   - `requirements.txt`
   - `Dockerfile`
   - `start.py`
3. Przejrzyj krótko te pliki:
   - `requirements.txt` zawiera m.in.:
     - `requests`
     - `fastapi`
     - `uvicorn[standard]`
   - `Dockerfile` jest przygotowany tak, aby:
     - Zainstalować zależności z `requirements.txt`.
     - Uruchomić aplikację FastAPI za pomocą Uvicorna na porcie `8000`.
   - `app.py` wystawia endpoint HTTP GET `/weather`, który oczekuje parametrów zapytania, np. `city` i `api_key`.

W ramach tego zadania nie musisz modyfikować powyższych plików – Twoim celem jest automatyzacja build/test/push za pomocą GitHub Actions.

---

## Część 2 – Utworzenie pliku workflow

4. Upewnij się, że w katalogu głównym repozytorium istnieje struktura:

   ```text
   .github/workflows
   ```

   Jeśli jej nie ma – utwórz ją.
5. Wewnątrz `.github/workflows` utwórz nowy plik:

   ```text
   06-06-app-pogoda.yaml
   ```

   Ten plik będzie zawierał kompletną definicję workflow CI.

---

## Część 3 – Nazwa workflow i wyzwalacze

6. Na początku pliku YAML zdefiniuj **name** workflow, np.:

   ```yaml
   name: "06-06 Pogoda API CI"
   ```

7. Skonfiguruj workflow, aby uruchamiał się w trzech sytuacjach:

   - `push` na gałęzie:
     - `feature/06-pogoda-api`
     - `main`
   - `pull_request` kierowany na gałąź:
     - `feature/06-pogoda-api`
   - ręcznie przez `workflow_dispatch`.

   W praktyce sekcja `on:` powinna zawierać:
   - blok `push` z `branches: [ feature/06-pogoda-api, main ]`,
   - blok `pull_request` z `branches: [ feature/06-pogoda-api ]`,
   - blok `workflow_dispatch` bez dodatkowych parametrów.

Dzięki temu CI uruchamia się automatycznie na zmianach w odpowiednich gałęziach i PR, a także pozwala na ręczne odpalenie.

---

## Część 4 – Definicja joba i zmiennych środowiskowych

8. W sekcji `jobs` utwórz job o identyfikatorze `build-and-test`:

   ```yaml
   jobs:
     build-and-test:
       runs-on: ubuntu-latest
   ```

9. W tym jobie zdefiniuj dwie zmienne środowiskowe w sekcji `env`:

   - `LOCAL_IMAGE_NAME` – nazwa lokalnego obrazu Dockera używanego do testów, np. `python_pogoda:test`.
   - `WORKDIR` – ścieżka do katalogu aplikacji, tj. `./CWICZENIA/06-context/pogoda_python_flusk`.

   Przykład:

   ```yaml
   env:
     LOCAL_IMAGE_NAME: python_pogoda:test
     WORKDIR: ./CWICZENIA/06-context/pogoda_python_flusk
   ```

Zmienne te będą używane w kolejnych krokach do budowy i uruchomienia obrazu.

---

## Część 5 – Kroki build i test

10. W jobie `build-and-test` dodaj sekcję `steps`.

### Krok 1 – Checkout repozytorium

11. Najpierw pobierz kod repozytorium:

    - Użyj akcji `actions/checkout@v4`.
    - Nadaj krokowi czytelną nazwę, np. `Checkout repository`.

    Dzięki temu runner będzie miał dostęp do `app.py`, `Dockerfile`, `requirements.txt` i `start.py`.

### Krok 2 – Budowa obrazu Dockera do testów

12. Dodaj krok, który buduje lokalny obraz Dockera z użyciem `Dockerfile` z katalogu `WORKDIR`:

    - Użyj komendy `docker build`.
    - Otaguj obraz nazwą z `LOCAL_IMAGE_NAME`.
    - Jako kontekst build użyj ścieżki z `WORKDIR`.

    Przykładowa komenda:

    ```bash
    docker build -t "$LOCAL_IMAGE_NAME" "$WORKDIR"
    ```

### Krok 3 – Uruchomienie kontenera

13. Dodaj krok uruchamiający kontener z zbudowanego obrazu:

    - Użyj `docker run -d`, aby wystartować kontener w tle.
    - Ustaw nazwę kontenera, np. `pogoda_api`.
    - Zmapuj port `8000` hosta na port `8000` kontenera: `-p 8000:8000`.
    - Przekaż zmienną środowiskową `OPENWEATHER_API_KEY`:
      - Wartość musi pochodzić z sekretu GitHuba: `${{ secrets.OPENWEATHER_API_KEY }}`.
    - Użyj `"$LOCAL_IMAGE_NAME"` jako nazwy obrazu.

    Przykład:

    ```bash
    docker run -d       --name pogoda_api       -p 8000:8000       -e OPENWEATHER_API_KEY="${{ secrets.OPENWEATHER_API_KEY }}"       "$LOCAL_IMAGE_NAME"
    ```

    > Przed użyciem workflow skonfiguruj sekret `OPENWEATHER_API_KEY` w ustawieniach repozytorium.

### Krok 4 – Oczekiwanie na start API

14. Dodaj krok, który daje API kilka sekund na start:

    - Użyj `sleep 10`.
    - Wypisz komunikat informacyjny.

    Np.:

    ```bash
    echo "Czekam na start API..."
    sleep 10
    ```

### Krok 5 – Test endpointu `/weather` za pomocą curl

15. Dodaj krok, który wywoła endpoint `/weather` przy użyciu `curl`:

    - Użyj `set -e`, aby skrypt zakończył się błędem przy pierwszym niepowodzeniu.
    - Użyj `curl -f`, aby status inny niż 2xx spowodował błąd.
    - Wywołaj endpoint pod adresem `http://localhost:8000/weather`.
    - Przekaż parametry zapytania:
      - `city=Warsaw`
      - `api_key` – z `${{ secrets.OPENWEATHER_API_KEY }}`.

    Przykład:

    ```bash
    set -e
    echo "Testowanie endpointu /weather..."
    curl -f "http://localhost:8000/weather?city=Warsaw&api_key=${{ secrets.OPENWEATHER_API_KEY }}"
    echo
    echo "OK - endpoint /weather zwrócił odpowiedź 2xx."
    ```

Jeżeli endpoint nie działa lub zwróci błąd, ten krok powinien zakończyć job niepowodzeniem.

### Krok 6 – Logi kontenera przy błędzie (debug)

16. Dodaj krok, który wypisuje logi kontenera **tylko w przypadku błędu joba**:

    - Użyj `if: failure()` w definicji kroku.
    - Użyj `docker logs pogoda_api` do wyświetlenia logów.
    - Dodaj `|| true`, aby krok nie zawiódł, jeśli kontener nie istnieje.

    Przykład:

    ```bash
    echo "Logi kontenera:"
    docker logs pogoda_api || true
    ```

### Krok 7 – Zatrzymanie i usunięcie kontenera (zawsze)

17. Dodaj krok sprzątający, który **zawsze** zatrzymuje i usuwa kontener `pogoda_api`:

    - Użyj `if: always()`.
    - Użyj `docker stop` i `docker rm` z `|| true`, aby uniknąć błędów, jeśli kontener już nie działa.

    Przykład:

    ```bash
    docker stop pogoda_api || true
    docker rm pogoda_api || true
    ```

Dzięki temu runner pozostaje czysty po każdym uruchomieniu workflow.

---

## Część 6 – Push do Docker Huba dla gałęzi main

18. Kolejne kroki powinny wykonywać się tylko wtedy, gdy:

    - Zdarzenie to `push` **oraz**
    - Gałąź to `main`.

    Użyj warunku:

    ```yaml
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    ```

### Krok 8 – Logowanie do Docker Huba

19. Dodaj krok logujący do Docker Huba:

    - Użyj akcji `docker/login-action@v3`.
    - Przekaż:
      - `username`: `${{ secrets.DOCKERHUB_USERNAME }}`
      - `password`: `${{ secrets.DOCKERHUB_TOKEN }}`

    > Przed uruchomieniem workflow skonfiguruj sekrety `DOCKERHUB_USERNAME` i `DOCKERHUB_TOKEN` w ustawieniach repozytorium.

### Krok 9 – Tagowanie obrazu dla Docker Huba

20. Dodaj krok przygotowujący tagi obrazu:

    - Oblicz skrócony SHA commita:

      ```bash
      SHORT_SHA="${GITHUB_SHA::7}"
      ```

    - Zbuduj nazwę bazową obrazu na Docker Hubie z użyciem nazwy użytkownika:

      ```bash
      HUB_IMAGE_BASE="${{ secrets.DOCKERHUB_USERNAME }}/python_pogoda"
      ```

    - Otaguj lokalny obraz (`$LOCAL_IMAGE_NAME`) dwoma tagami:
      - `$HUB_IMAGE_BASE:latest`
      - `$HUB_IMAGE_BASE:$SHORT_SHA`

    Przykładowy skrypt:

    ```bash
    SHORT_SHA="${GITHUB_SHA::7}"
    HUB_IMAGE_BASE="${{ secrets.DOCKERHUB_USERNAME }}/python_pogoda"

    echo "Taguję obraz:"
    echo " - $HUB_IMAGE_BASE:latest"
    echo " - $HUB_IMAGE_BASE:$SHORT_SHA"

    docker tag "$LOCAL_IMAGE_NAME" "$HUB_IMAGE_BASE:latest"
    docker tag "$LOCAL_IMAGE_NAME" "$HUB_IMAGE_BASE:$SHORT_SHA"
    ```

### Krok 10 – Push obrazów do Docker Huba

21. Dodaj końcowy krok wypychający oba tagi do Docker Huba:

    - Użyj `docker push` dla:
      - `$HUB_IMAGE_BASE:latest`
      - `$HUB_IMAGE_BASE:$SHORT_SHA`

    Przykład:

    ```bash
    SHORT_SHA="${GITHUB_SHA::7}"
    HUB_IMAGE_BASE="${{ secrets.DOCKERHUB_USERNAME }}/python_pogoda"

    docker push "$HUB_IMAGE_BASE:latest"
    docker push "$HUB_IMAGE_BASE:$SHORT_SHA"
    ```

Po pomyślnym uruchomieniu na gałęzi `main` obraz Dockera dla pogodowego API będzie opublikowany w Docker Hubie z tagami `latest` oraz skróconym SHA.

---

## Część 7 – Commit, push i weryfikacja

22. Zapisz plik workflow:

    ```text
    .github/workflows/06-06-app-pogoda.yaml
    ```

23. Wykonaj commit i push:

    ```bash
    git add .github/workflows/06-06-app-pogoda.yaml
    git commit -m "Dodaj workflow CI dla zdokeryzowanego pogodowego API"
    git push
    ```

24. Zweryfikuj działanie workflow:

    - Dla gałęzi feature:
      - Utwórz lub zaktualizuj gałąź `feature/06-pogoda-api`.
      - Wypchnij zmiany i sprawdź uruchomienie workflow w zakładce **Actions**.
    - Dla pull requestu:
      - Utwórz PR kierowany na `feature/06-pogoda-api`.
      - Sprawdź, czy workflow wystartował automatycznie.
    - Dla gałęzi main:
      - Zmerguj lub wypchnij zmiany do `main`.
      - Upewnij się, że:
        - Obraz został zbudowany i przetestowany.
        - Obraz został wypchnięty do Docker Huba z odpowiednimi tagami.

---

## Rezultat

Rezultatem zadania jest **plik YAML workflow**:

```text
.github/workflows/06-06-app-pogoda.yaml
```

Plik musi zawierać:

- Opisaną konfigurację triggerów (`push`, `pull_request`, `workflow_dispatch`).
- Job `build-and-test` na `ubuntu-latest`.
- Zmienne `LOCAL_IMAGE_NAME` i `WORKDIR`.
- Kroki:
  - checkout kodu,
  - budowa obrazu Dockera,
  - uruchomienie kontenera z sekretem `OPENWEATHER_API_KEY`,
  - oczekiwanie na start API,
  - test endpointu `/weather` przy użyciu `curl`,
  - logi kontenera przy błędzie,
  - sprzątanie kontenera.
- Dodatkowe kroki (tylko dla push na `main`):
  - logowanie do Docker Huba,
  - tagowanie obrazu,
  - push obrazów na Docker Huba.

Spełnienie wszystkich powyższych punktów oznacza poprawne wykonanie zadania.
