# Practical Exercise 22 - Creating a Composite Custom Action

## English Version

### Exercise Description

In this practical exercise, our goal is to explore the syntax of and how to create composite custom actions in GitHub Actions.

The goal of our composite custom action is to handle the installation and caching of npm dependencies, and to abstract that behind an easy-to-use reusable action. Here are the instructions for the exercise:

1. Create a file named `action.yaml` under the folder `.github/actions/composite-cache-deps`. This folder does not exist yet, so you might have to create it.
2. In the `action.yaml` file, add the following properties:
   - a. A `name` of `Cache Node and NPM Dependencies`;
   - b. A `description` of `"This action allows to cache both Node and NPM dependencies based on the package-lock.json file."`;
   - c. The action should receive two inputs:
     - i. The first one, named `node-version`, should be required, have a description of `NodeJS version to use`, and default to `20.x`.
     - ii. The second one, named `working-dir`, should not be required, have a description of `The working directory of the application`, and default to the current directory if no input is passed.
   - d. Add a top-level `runs` key. This is the core of defining our composite custom action. For a composite custom action, the `runs` key has the following shape:
     - i. `runs:`
     - ii. `using: composite`
     - iii. `steps: [...]`
      - where:
        - `using: composite` simply informs GitHub Actions that this is a composite custom action.
        - `steps: [...]` contains the array of steps you wish to execute. This is very similar to the steps we have already defined for jobs in our previous exercises.
   - e. Add the following steps under the steps key:
     - i. The first step, named `Setup NodeJS version <retrieve the node-version input value here>`, should setup NodeJS by using the provided version from the inputs.
     - ii. The second step, named `Cache dependencies`, should have an id of `cache`, and use the `actions/cache` action to cache the `node_modules` path under the provided working directory, and using a suitable key. Check the Tips section below for how to calculate the key effectively.
     - iii. The third step, named `Install dependencies`, should run if and only if there was not a cache hit in step two. It should run the `npm ci` script under the provided `working-dir` input, and it should use the `bash` shell.
3. Commit the changes and push the code. Take a few moments to understand the syntax of the composite custom action and the similarities and differences to the steps of a job. For now, nothing will happen, since this custom action is not used in any workflow, so let's move on to the next exercise where we create our workflow!

### Tips

**Calculating the key for our cache**

When calculating the key, we should take into consideration our package-lock.json file which is under the provided working directory. We should not look at all package-lock.json files, since there may be more than one project within our repository (which is actually the case for us), and this may lead to incorrect changes in the cache key due to changes in unrelated files. In order to hash files and use the provided working directory from within an expression, you can use the following syntax:

```
your-key-prefix-${{ hashFiles(format('{0}/{1}', inputs.working-dir, 'package-lock.json')) }}
```

---

## Wersja Polska

### Opis Ćwiczenia

W tym ćwiczeniu praktycznym naszym celem jest poznanie składni oraz sposobu tworzenia złożonych akcji niestandardowych (composite custom actions) w GitHub Actions.

Celem naszej akcji złożonej jest obsługa instalacji i buforowania zależności npm oraz ukrycie tego za prostą, wielokrotnego użytku akcją. Oto instrukcje do ćwiczenia:

1. Utwórz plik o nazwie `action.yaml` w folderze `.github/actions/composite-cache-deps`. Folder ten może nie istnieć, więc być może będziesz musiał go utworzyć.
2. W pliku `action.yaml` dodaj następujące właściwości:
   - a. `name` ustaw na `Cache Node and NPM Dependencies`;
   - b. `description` ustaw na `"This action allows to cache both Node and NPM dependencies based on the package-lock.json file."`;
   - c. Akcja powinna przyjmować dwa parametry wejściowe (inputs):
     - i. Pierwszy, o nazwie `node-version`, powinien być wymagany, mieć opis `NodeJS version to use` i domyślną wartość `20.x`.
     - ii. Drugi, o nazwie `working-dir`, nie powinien być wymagany, mieć opis `The working directory of the application`, i domyślnie wskazywać bieżący katalog, jeśli nie podano innej wartości.
   - d. Dodaj klucz najwyższego poziomu `runs`. To kluczowy element definiujący akcję złożoną. Dla takiej akcji klucz `runs` ma następującą strukturę:
     - i. `runs:`
     - ii. `using: composite`
     - iii. `steps: [...]`
      - gdzie:
        - `using: composite` informuje GitHub Actions, że jest to akcja złożona.
        - `steps: [...]` zawiera tablicę kroków do wykonania. Jest to bardzo podobne do kroków, które definiowaliśmy wcześniej w zadaniach dla jobów.
   - e. Dodaj następujące kroki pod kluczem `steps`:
     -  i. Pierwszy krok, nazwany `Setup NodeJS version <retrieve the node-version input value here>`, powinien skonfigurować NodeJS przy użyciu przekazanej wersji z wejścia.
     -  ii. Drugi krok, nazwany `Cache dependencies`, powinien mieć identyfikator `cache` i używać akcji `actions/cache` do buforowania ścieżki `node_modules` w przekazanym katalogu roboczym przy użyciu odpowiedniego klucza. Sprawdź sekcję **Tips** poniżej, aby dowiedzieć się, jak skutecznie obliczyć klucz.
     -  iii. Trzeci krok, nazwany `Install dependencies`, powinien być uruchamiany tylko wtedy, gdy w drugim kroku nie znaleziono pamięci podręcznej. Powinien uruchomić skrypt `npm ci` w katalogu określonym przez `working-dir`, używając powłoki `bash`.
3. Zatwierdź zmiany i wypchnij kod. Poświęć chwilę, aby zrozumieć składnię akcji złożonej oraz podobieństwa i różnice w stosunku do kroków w jobach. Na razie nic się nie stanie, ponieważ ta akcja nie jest używana w żadnym workflow — przejdźmy więc do następnego ćwiczenia, w którym utworzymy nasz workflow!

### Wskazówki

**Obliczanie klucza dla naszej pamięci podręcznej**

Podczas obliczania klucza powinniśmy wziąć pod uwagę plik `package-lock.json`, który znajduje się w podanym katalogu roboczym. Nie powinniśmy brać pod uwagę wszystkich plików `package-lock.json`, ponieważ w repozytorium może być wiele projektów (co w naszym przypadku jest prawdą), co mogłoby prowadzić do błędnych zmian w kluczu pamięci podręcznej z powodu zmian w niepowiązanych plikach. Aby obliczyć hash pliku i użyć podanego katalogu roboczego w wyrażeniu, możesz użyć następującej składni:

```
your-key-prefix-${{ hashFiles(format('{0}/{1}', inputs.working-dir, 'package-lock.json')) }}
```
